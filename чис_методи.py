# -*- coding: utf-8 -*-
"""ЧисМетодиДЗ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pz3XJva8PH5LWFlTWe5syb-M5T8FF4wz
"""

#-------------------------ДІЛЕННЯ НАВПІЛ----------------------------------------

#функція, що шукає середину відрізка xy
def average(x, y):
    return (x+y)/2

#функція, яка перевіряє чи достатньо малий інтервал
def smallInterval(x, y, eps):
    if abs(x-y)<eps:
        return 1
    return 0

#функція ділення навпіл
def divisionInHalf(f, pointA, pointB, eps):
    middle=average(pointA, pointB)
    if smallInterval(pointA, pointB, eps):
        return middle
    testValue=f(middle)
    if testValue>0:
        return divisionInHalf(f, pointA, middle, eps)
    elif testValue<0:
        return divisionInHalf(f, middle, pointB, eps)
    return middle

#функція, який перевіряє різність знаків на кінцях і якщо все ОК, викликає функцію ділення навпіл
def halfIntervalMethod(f, a ,b, eps):
    valueA=f(a)
    valueB=f(b)
    if valueA>0 and valueB<0:
        return divisionInHalf(f, b, a, eps)
    elif valueA<0 and valueB>0:
        return divisionInHalf(f, a, b, eps)
    else:
        print("Аргументи мають різні знаки")
        return 0

#Задаємо функцію
def f(x):
    return x**3 + 2*x - 1

a = 0
b = 1
eps = 0.001
halfIntervalMethod(f, a , b, eps)

#------------------------МЕТОД ПРОСТОЇ ІТЕРАЦІЇ---------------------------------

import math

#Задаємо функцію
def f(x):
  return math.atan(x+4)+3
  # return x**3 + 2*x - 1

# переписуємо f(x)=0 на еквівалентну функцію x = g(x)
def g(x):
  return (x-17*(math.atan(x+4)+3))
  # return x - 0.2*(x**3 + 2*x - 1)

# Метод простої ітерації
def simpleIteration(x0, eps, N):
    print('\n\n--- Метод простої ітерації ---')
    counter = 1
    flag = 1
    condition = True
    while condition:
        x1 = g(x0)
        print('Ітерація-%d, x1 = %0.6f --> f(x1) = %0.6f' % (counter, x1, f(x1)))
        x0 = x1
        counter = counter + 1
        if counter > N:
            flag=0
            break
        condition = abs(f(x1)) > eps

    if flag==1:
        print('\nКорінь рівняння: %0.8f' % x1)
    else:
        print('\nУмова збіжності не виконується.')

# Введення даних
x0 = 1          #Початкове наближення
eps = 0.0001       #Точність
N = 10            #Максимальна к-ть ітерацій(захист вд зациклювання)

# x0 = float(input('Початкове наближення: '))
# eps = float(input('Точність: '))
# N = int(input('Максимальна к-ть ітерацій: '))

# Виклик функції простої ітерації
simpleIteration(x0,eps,N)

#------------------------МЕТОД НЬЮТОНА ---------------------------------
from sympy import diff

#Задаємо функцію
def f(x):
  return x**3 - 6*x**2 + 20

#функція, що повертає значення похідної в заданій точці
def f_derivative(differ, x):
  differ = str(differ)
  differ = differ.replace('x',str(x))
  result = eval(differ)                   #робимо з рядка дійсне числове значення
  return result

#метод Ньютона
def newtons_method(f, differ, x0, epsilon):
  count = 0
  delta = 1
  while delta > epsilon:
    x = x0 - f(x0) / f_derivative(differ,x0)
    delta = abs(x-x0)
    x0=x
    #захист від зациклювання
    count += 1
    if(count>30):
      break
  print(x)


func = 'x**3 - 6*x**2 + 20'   #записуємо функцію, щоб далі знайти похідну
differ = diff(func)           #змінна, що містить в собі похідну заданої функції
x0 = 5                        #початкове наближення
epsilon = 0.0001              #точність

newtons_method(f, differ, x0, epsilon)

#-------------------------------МЕТОД ГАУССА -----------------------------------

def gaussian_method(A, b):
    # Прямий хід
    n = len(A)                    #обчислюємо розмірність системи лінійних рівнянь як довжину вектора b
    for i in range(n):
        if A[i][i] == 0:
            #Якщо елемент на головній діагоналі дорівнює нулю, то шукаємо ненульовий рядок нижче або вище та міняємо місцями поточний рядок з першим знайденим ненульовим рядком.
            found = False
            for j in range(i+1, n):
                if A[j][i] != 0:
                    A[i], A[j] = A[j], A[i]
                    b[i], b[j] = b[j], b[i]
                    found = True
                    break
            if not found:
                for j in range(i-1, -1, -1):
                    if A[j][i] != 0:
                        A[i], A[j] = A[j], A[i]
                        b[i], b[j] = b[j], b[i]
                        found = True
                        break
            if not found:
                raise ValueError("Нульовий елемент на головній діагоналі")

        #для кожного рівняння нижче діагоналі (j > i), ми знаходимо коефіцієнт ratio, який показує, наскільки ми повинні зменшити поточний рядок i,
        #щоб усунути невідому x_i з цього рівняння. Ми віднімаємо цей коефіцієнт, помножений на рядок i, з рядка j матриці A, щоб отримати новий рядок для рівняння j
        #Аналогічно також оновлюємо елемент j вектора вільних членів b.
        for j in range(i+1, n):
            ratio = A[j][i] / A[i][i]
            for k in range(i, n):
                A[j][k] -= ratio * A[i][k]
            b[j] -= ratio * b[i]

    #починаємо зворотний хід методу Гауса, проходячи по діагоналі матриці A у зворотному порядку. Для кожного рівняння вище діагоналі (j < i),
    #виражаємо змінну x_j через змінні, які ми вже розрахували, використовуючи нове значення x_i, яке ми щойно знайшли. Оновлюємо елемент j вектора вільних членів b
    x = [0] * n
    for i in range(n-1, -1, -1):
        # if A[i][i] == 0:
        #     raise ValueError("Нульовий елемент на головній діагоналі")
        x[i] = b[i] / A[i][i]
        for j in range(i-1, -1, -1):
            b[j] -= A[j][i] * x[i]

    return x

# Створюємо матрицю коефіцієнтів для СЛАР:
#2x + y - z = 8
#4x - 6y     = -2
#-2x + 7y + 2z = 7
A = [[2, 1, -1], [4, -6, 0], [-2, 7, 2]]
b = [8, -2, 7]
# A = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]
# b = [1, 1, 1]

#Викликаємо метод Гаусса
gaussian_method(A, b)

#-------------------------------МЕТОД ПРОГОНКИ ---------------------------------

def tridiagonal_method(a, b, c, d):
    # На прямому ході ми спочатку обчислюємо перший прогонний коефіцієнт c [0] і перший прогонний член d [0].
    # Потім, використовуючи рекурентні формули, обчислюємо інші прогонувальні коефіцієнти c[i] і прогонувальні члени d[i] для i від 1 до n-1
    n = len(b)
    c[0] /= b[0]
    d[0] /= b[0]
    for i in range(1, n):
        m = 1 / (b[i] - a[i] * c[i-1])
        c[i] *= m
        d[i] = (d[i] - a[i] * d[i-1]) * m

    #На зворотному ході ми починаємо з останнього рівняння та обчислюємо рішення x[n-1].
    #Потім, використовуючи рекурентну формулу, обчислюємо рішення x[i] для i від n-2 до 0
    x = [0] * n
    x[-1] = d[-1]
    for i in range(n-2, -1, -1):
        x[i] = d[i] - c[i] * x[i+1]
    #повертаємо вектор рішень x
    return x

#Перший варіант
# 3x[0] + 1x[1]                 = 2
# 1x[0] + 5x[1] + 2x[2]         = -4
#         2x[1] + 4x[2] + 1x[3] = 1
#                 1x[2] + 3x[3] = -2

# a = [0, 1, 1, 1]   # коефіцієнти під діагоналлю
# b = [3, 3, 3, 3]   # коефіцієнти на головній діагоналі
# c = [1, 1, 1, 0]   # коефіцієнти над діагоналлю
# d = [4, 5, 5, 4] # вільні члени
#Другий варіант
# 9x[0] -  3x[1]                  = -25
# -1x[0] - 1x[1] + 5x[2]          = -4
#        - 6x[1] - 9x[2] + 0*x[3] = 1
#                  0*x[2] + 7x[3] = -2

# a = [0, -1, -6, 0]   # коефіцієнти під діагоналлю
# b = [9, -1, -9, 7]   # коефіцієнти на головній діагоналі
# c = [-3, 5, 0, 0]   # коефіцієнти над діагоналлю
# d = [-25, 25, -62, 27] # вільні члени

a = [0.000, 1.710, 1.050, 1.320, 1.830]   # коефіцієнти під діагоналлю
b = [4.080, 4.400, 4.780, 4.810, 4.620]   # коефіцієнти на головній діагоналі
c = [1.620, 1.270, 1.100, 1.370, 0.000]   # коефіцієнти над діагоналлю
d = [0.810, 2.200, 0.525, 1.370, 4.620] # вільні члени

x = tridiagonal_method(a, b, c, d)
print(x)

#-------------------------------МЕТОД ЯКОБІ-------------------------------------

import numpy as np

def jacobi_method(A, b, x0, eps=0.001, max_iter=100):
    n = len(b)                      # кількість невідомих
    x = x0.copy()                   # копіюємо початкове наближення, щоб не змінювати оригінальний вектор
    x_new = np.zeros_like(x)        # створюємо новий вектор для нових значень невідомих
    counter = 0                     # лічильник ітерацій
    #Цей блок коду містить основний цикл методу Якобі. Ми виконуємо 'max_iter' ітерацій, на кожній ітерації оновлюючи значення x для кожного рівняння у системі.
    #Для кожного рівняння ми обчислюємо суму всіх членів, крім діагонального, та віднімаємо її з правої частини. Потім ділимо відповідний діагональний елемент матриці A
    while counter < max_iter:     # виконуємо ітерації, доки не досягнемо максимальної кількості ітерацій
        for i in range(n):          # для кожної невідомої і обчислюємо нове значення
            s = 0                   # сума для всіх j! = i
            for j in range(n):
                if j != i:
                    s += A[i, j] * x[j]     # обчислюємо суму
            x_new[i] = (b[i] - s) / A[i, i] #обчислюємо нове значення i-ої невідомої
         #перевіряємо, як сильно змінилося значення x з попередньої ітерації. Якщо різниця менша за eps, ми вважаємо, що метод Якобі зійшовся, і повертаємо знайдене рішення
        if np.linalg.norm(x - x_new) < eps:
            return x_new, counter
        x = x_new.copy()        # перезаписуємо значення невідомих на нові
        counter += 1            # збільшуємо лічильник ітерацій
    raise ValueError("Метод Якобі не зійшовся за вказану кількість ітерацій")

# A = np.array([[10, 1, -1],
#               [1, 10, -1],
#               [-1, 1, 10]])
# b = np.array([20, 20, 20])

A = np.array([[4, -1, 0],
              [-1, 4, -1],
              [0, -1, 4]])

b = np.array([10, 10.5, 10.5])

x0 = np.zeros_like(b)

x_sol, num_iter = jacobi_method(A, b, x0)
print("Розв'язок системи: ", x_sol)
print("Кількість ітерацій: ", num_iter)

import numpy as np
#-----------МЕТОД ЛАГРАНЖА ДЛЯ ПОБУДОВИ ІНТЕРПОЛЯЦІЙНИХ ПОЛІНОМІВ---------------

#функція arctan(2x)
def f(x):
  return np.arctan(2*x)

#повертає значення інтерполяційного полінома Лагранжа в точці x
def lagrange_interpolation(x_values, y_values, x):
    n = len(x_values)
    lagrange_polynomial = 0

    for i in range(n):
        # обчислюємо коефіцієнт l_i
        l_i = 1
        for j in range(n):
            if i != j:
                l_i *= (x - x_values[j]) / (x_values[i] - x_values[j])
        # додаємо до полінома добуток l_i на відповідне значення функції f(x)
        lagrange_polynomial += y_values[i] * l_i

    return lagrange_polynomial


#список значень x вузлів інтерполяції
x_values = [-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1]
#список значень функції f(x) вузлів інтерполяції
y_values = [f(-1), f(-0.75), f(-0.5), f(-0.25), f(0), f(0.25), f(0.5), f(0.75), f(1)]

#x - точки, в яких потрібно обчислити значення інтерполяційних поліномів
for x in  -0.9, -0.3, 0.3, 0.9 :
  lagrange_polynomial = lagrange_interpolation(x_values, y_values, x)
  print("Значення інтерполяційного полінома Лагранжа в точці x = {}: {}".format(x, lagrange_polynomial))

#-------------МЕТОД ЧЕБИШЕВА ДЛЯ ПОБУДОВИ ІНТЕРПОЛЯЦІЙНИХ ПОЛІНОМІВ-------------
import numpy as np

#Функція, що повертає n чебишевських вузлів на відрізку [-1, 1].
def chebyshev_nodes(n):
    return np.cos((2*np.arange(1, n+1) - 1)*np.pi/(2*n))

# Функція, що обчислює інтерполяційний поліном за допомогою n чебишевських вузлів.
def chebyshev_interpolation(n, f):
    nodes = chebyshev_nodes(n)
    values = f(nodes)
    #values = []
    #використовуємо функцію chebfit для знаходження коефіцієнтів інтерполяційного полінома
    coeffs = np.polynomial.chebyshev.chebfit(nodes, values, n-1)
    #використовуємо функцію chebval для обчислення значення інтерполяційного полінома в заданій точці
    return lambda x: np.polynomial.chebyshev.chebval(x, coeffs)

# Приклад використання
def f(x):
    return np.arctan(2*x)

n = 9
poly = chebyshev_interpolation(n, f)

# виводимо значення інтерполяційного полінома в точцках x=-0.9, x=-0.3, x=0.3, x=0.9
for x in -0.9, -0.3, 0.3, 0.9:
  print("P(", x ,") = ", poly(x))

#-----ОБЧИСЛЕННЯ ІНТЕГРАЛІВ ЗА МЕТОДАМИ ПРЯМОКУТНИКІВ, ТРАПЕЦІЙ ТА СІМПСОНА-----
import math
from scipy import integrate
import numpy as np
from scipy.misc import derivative

#Метод прямокутників
def rectangular_rule(a, b, n, f):
   h = (b - a) / n
   integral = 0
   for i in range(n):
     xi = a + i * h + h / 2
     integral += h * f(xi)
   return integral

#Метод трапецій
def trapezoidal_rule(a, b, n, f):
    h = (b - a) / n
    integral = 0
    for i in range(n):
        xi = a + i * h
        xi_1 = a + (i + 1) * h
        integral += h * (f(xi) + f(xi_1)) / 2
    return integral

#Метод Сімпсона
def simpsons_rule(a, b, n, f):
    h = (b - a) / n
    integral = 0
    for i in range(n):
        xi = a + i * h
        xi_1 = a + (i + 1) * h
        x_mid = (xi + xi_1) / 2
        integral += h / 6 * (f(xi) + 4 * f(x_mid) + f(xi_1))
    return integral

# Рахуємо інтеграл 3-ма методами і виводимо результати та похибки
def compute_integral(a, b, n, f, M2, M4):
    real_integral = integrate.quad(f, a, b)[0]
    rect_integral = rectangular_rule(a, b, n, f)
    trap_integral = trapezoidal_rule(a, b, n, f)
    simp_integral = simpsons_rule(a, b, n, f)
    #довжина відрізку
    h = (b-a) / n
    #Теоретичні оцінки похибок
    rect_error = M2 * (b-a) * h**2 / 24
    trap_error = M2 * (b-a) * h**2 / 12
    simp_error = M4 * (b-a) * h**4 / 2880
    print("Бібліотечний інтеграл = ", real_integral)
    print("\nІнтеграл методом прямокутників = ", rect_integral)
    print("Інтеграл методом трапецій = ", trap_integral)
    print("Інтеграл методом Сімпсона = ", simp_integral)
    print("\nМаксимально можлива теоретична похибка для методу прямокутників = ", rect_error)
    print("Максимально можлива теоретична похибка для методу трапецій = ", trap_error)
    print("Максимально можлива теоретична похибка для методу Сімпсона = ", simp_error)
    #Реальні похибки
    rect_error_real = abs(rect_integral-real_integral)
    trap_error_real = abs(trap_integral-real_integral)
    simp_error_real = abs(simp_integral-real_integral)
    print("\nРеальна похибка для методу прямокутників = ", rect_error_real)
    print("Реальна похибка для методу трапецій = ", trap_error_real)
    print("Реальна похибка для методу Сімпсона = ", simp_error_real)

# Функція для знаходження максимуму модулю другої похідної функції на [a,b]
def max_second_derivative(f, a, b):
    x_vals = np.linspace(a, b, 1000)
    second_derivs = [abs(derivative(f, x, n=2)) for x in x_vals]
    return max(second_derivs)

# Функція для знаходження максимуму модулю четвертої похідної функції на [a,b]
def max_fourth_derivative(f, a, b):
    x_vals = np.linspace(a, b, 1000)
    fourth_derivs = [abs(derivative(f, x, n=4, order=5)) for x in x_vals]
    return max(fourth_derivs)


#-------------------------ПРИКЛАД ЗАСТОСУВАННЯ-----------------------------------
# Функція
def f(x):
    return math.sin(x)

# Межі інтегрування
a = 0
b = math.pi

#максимум модулю 2-ї та 4-ї похідної функції на [a,b]
# M2 = max_second_derivative(f, a, b)
# M4 = max_fourth_derivative(f, a, b)
M2 = 1
M4 = 1

# Розбиваємо початковий проміжок на 20 частин
n = 20

compute_integral(a, b, n, f, M2, M4)

#-------------------------------Число Белла-------------------------------------
def bell_number(n):
    if n == 0:
        return 1
    bell = 0
    for k in range(n):
        bell += binomial_coefficient(n-1, k) * bell_number(k)
    return bell

def binomial_coefficient(n, k):
    if k == 0 or k == n:
        return 1
    return binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)

n = 7
print(f"Число Белла для n = {n}: {bell_number(n)}")

from scipy.stats import poisson

p1 = 0.02
p2 = 0.08
k_max = 4
n = 1

while True:
    lambda1 = n * p1
    lambda2 = n * p2
    sum_p1 = 0
    sum_p2 = 0
    for k in range(k_max + 1):
        sum_p1 += poisson.pmf(k, lambda1)
        sum_p2 += poisson.pmf(k, lambda2)
    if sum_p1 > 0.9 and sum_p2 < 0.05:
        break
    n += 1

print(f"Lambda0 = {round(n * p1, 1)}, lambda1 = {round(n * p2,1)}, n = {n}")

sum1=0
sum2=0
for i in range(k+1):
  sum1+=poisson.pmf(i, n * p1)
  sum2+=poisson.pmf(i, n * p2)

print(f"\n Lambda0 = {round(n * p1, 1)}, p={p1} -> sum = {sum1}")
for i in range(k+1):
    print(f"k={i}, poison = {poisson.pmf(i, n * p1)}")

print(f"\n Lambda1 = {round(n * p2, 1)}, p={p2} -> sum = {sum2}")
for i in range(k+1):
    print(f"k={i}, poison = {poisson.pmf(i, n * p2)}")